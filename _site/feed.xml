<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-11-01T00:15:36+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">學徒筆記</title><subtitle>邁向偉大的航道</subtitle><author><name>srhuang</name></author><entry><title type="html">What’s Difference between Divide and Conquer, Backtracking, Dynamic Programming ?</title><link href="http://localhost:4000/algorithm/2019/10/31/algorithm-001.html" rel="alternate" type="text/html" title="What's Difference between Divide and Conquer, Backtracking, Dynamic Programming ?" /><published>2019-10-31T00:00:00+08:00</published><updated>2019-10-31T00:00:00+08:00</updated><id>http://localhost:4000/algorithm/2019/10/31/algorithm-001</id><content type="html" xml:base="http://localhost:4000/algorithm/2019/10/31/algorithm-001.html">&lt;p&gt;在刷 code 的漫長旅程中，穿梭在各個類型的題目中，很容易讓人失去了方向。
讓我們用演算法來解決人生的大小事吧！今天討論的三種方法：Divide and Conquer, Backtracking, DP，以解決人生難題為例，如何實際應用這三種方法，成功找到幸福的鑰匙。&lt;/p&gt;

&lt;!--more--&gt;
&lt;h2 id=&quot;化整為零&quot;&gt;化整為零&lt;/h2&gt;
&lt;p&gt;今天要討論的這三種方法，最大的共同點就是「把主問題分解成一個一個的小問題，化整為零後，各個擊破。」這背後的人生哲學其實也很值得我們借鏡，當我們面臨人生大大小小的難題時，很多人會沉陷在一開始面臨的大問題中，感覺到無力、沮喪、甚至自我厭惡，進而引發自卑情結，或是轉向無用的優越情結。但總是有另外一群人，異常的冷靜，雖然還是會有情緒，但總是很快的回過神來解決問題，慢慢的把大問題分解成一個一個可以處理的小問題，然後開始動手去做。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;演算法就是解決問題的方法。
面對人生難題，也可以運用演算法！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;divide-and-conquer-各自為政&quot;&gt;Divide and Conquer 各自為政&lt;/h2&gt;
&lt;p&gt;Divide and Conquer 最大的特色就是「每個子問題都是獨立的」。假設今天終於有機會可以跟心儀已久的妹子出去約會，該如何設計一個成功的約會呢？面對這個大問題，可以分解成「上午的行程」、「下午的行程」、「晚上的行程」子問題，如果過程順利，還要準備「過夜行程」。&lt;/p&gt;

&lt;p&gt;上午行程，適合靜態的活動，也可以讓彼此暖身並且熟悉對方的節奏，一間東西好吃、氣氛很好的早午餐是更好不過的選擇了，讓彼此可以坐著好好的面對面聊天，嘗試尋找切入點，為接下來的相處做好準備。&lt;/p&gt;

&lt;p&gt;下午行程，根據太陽角度大致分成三點前和三點後。三點前的太陽太烈，如果安排戶外活動，容易讓人覺得煩躁，更慘的是有可能讓女生因為滿頭大汗而狼狽不堪，因此三點前的行程適合室內看看展覽，或是有冷氣的地方。當然，如果要走展覽路線，一定要確保是自己熟悉的領域，也可以藉機讓對方更認識不一樣的自己。三點後的行程就很適合戶外活動，此時的太陽不那麼炙熱，好好的享受午後時光，會讓人有幸福的錯覺，馴服她的直覺，讓你和感到幸福產生連結，就成功一半了。騎個腳踏車，爬個小山，或是逛個老街，都是很不錯的選擇，如果能有個戶外活動必須兩個人一起完成那就更好了。最後選擇可以看美景或是夕陽的地方，感嘆一下及時行樂(yolo 你懂的～)。&lt;/p&gt;

&lt;p&gt;晚上行程，一頓浪漫的大餐是少不了的，東西可以吞嚥就好，重點氣氛要夠，最好是有駐唱的那種，讓她有種「人生至此，夫復何求」的感覺。吃過晚餐可以先在附近走走，散步聊天，至少要撐過晚上八點，然後開始提議有間可以看夜景喝咖啡的景觀餐廳還不錯，如果對方還願意給你機會表現，此時的達陣率至少有八成了。最後就前往你去到爛掉的老地方，大家好好坐下來聊聊，心中最軟的那一塊。&lt;/p&gt;

&lt;p&gt;過夜行程，Motel。&lt;/p&gt;

&lt;h2 id=&quot;backtracking-斬立決&quot;&gt;Backtracking 斬立決&lt;/h2&gt;
&lt;p&gt;在求偶的旅程中，一定要懂的演算法就是「Backtracking」了，應該要好好的推廣這個觀念，這樣就不會有恐怖情人出現了，面對不對的人，斬立決就對了。Backtracking 其實就是窮舉所有可能，在某個階段發現該 Solution 不是對的時候，立馬停止向下展開，這種技巧叫做「pruning」，以達到優化效率的目的。&lt;/p&gt;

&lt;h2 id=&quot;dynamic-programming-鑑往知來&quot;&gt;Dynamic Programming 鑑往知來&lt;/h2&gt;
&lt;p&gt;DP 和 Divide and Conquer 最大的差別在於，DP 的子問題有可能會 overlapping，因此遇到以前遇過的就不需要全部重頭來過，可以鑑往知來。就像安排跟妹子約會的行程，你總是會有口袋名單，好的地方值得一去再去，因此安排行程就會越來越簡單，重點不是去了什麼地方，而是跟誰去，只要該約會地點值得信賴，就不需要再浪費心思去踩雷了，相對的你的表現也會越發自信，進而觸發對方的費洛蒙，成功達陣的機會就會大很多了，共勉之。&lt;/p&gt;

&lt;h2 id=&quot;經典例子&quot;&gt;經典例子&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Divide and Conquer : merge sort。每個子問題都是各自獨立，不相重複，而且必須解完所有子問題，才能解決主問題。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Backtracking : 數獨。窮舉所有可能，一旦發現該格填入數字不合法後，就不需要再往下窮舉了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Dynamic Programming : 費式數列。使用 recursion 時，會發現有很多子問題重複計算，這時候需要 DP Table 做紀錄，一旦遇到相同子問題時，只需要查表就可，不需要重複計算，這種技巧叫做「memoization」。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;details&gt;
    &lt;summary&gt;memoization？memorization？
&lt;/summary&gt;
「memoization」是計算機科學的特殊專有名詞，出自 Algorithm 經典書 「CLRS」p.347。
「memorization」根據劍橋的翻譯：the act or process of learning something so that you will remember it exactly.
&lt;/details&gt;

&lt;h2 id=&quot;conclusion-結論&quot;&gt;Conclusion 結論&lt;/h2&gt;
&lt;p&gt;Divide and Conquer 會聯想到「independent subproblem」；Backtracking 的特徵是「pruning」；Dynamic Programming 的核心是「memoization」。
還有很多細節都被省略了，但希望這篇文章能夠提供「overview」的角度來思考這三個演算法，祝大家刷題愉快！&lt;/p&gt;</content><author><name>srhuang</name></author><summary type="html">在刷 code 的漫長旅程中，穿梭在各個類型的題目中，很容易讓人失去了方向。 讓我們用演算法來解決人生的大小事吧！今天討論的三種方法：Divide and Conquer, Backtracking, DP，以解決人生難題為例，如何實際應用這三種方法，成功找到幸福的鑰匙。</summary></entry><entry><title type="html">The difference between a++ and ++a from assembly code</title><link href="http://localhost:4000/c/2019/10/06/c-001.html" rel="alternate" type="text/html" title="The difference between a++ and ++a from assembly code" /><published>2019-10-06T00:00:00+08:00</published><updated>2019-10-06T00:00:00+08:00</updated><id>http://localhost:4000/c/2019/10/06/c-001</id><content type="html" xml:base="http://localhost:4000/c/2019/10/06/c-001.html">&lt;p&gt;以下是科技公司面試常考的考題，主要是測驗你對於 a++ 和 ++a 的認知。&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9527&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a=%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;請問上面這段程式碼會印出什麼？&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;我們首先想要了解 &lt;code class=&quot;highlighter-rouge&quot;&gt;a++&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;++a&lt;/code&gt; 的差別，就要去看它們所產生出來的 assembly code。&lt;/p&gt;

&lt;p&gt;先介紹一個可以線上產生 assembly code 的網站，可以幫助我們快速深刻的了解 C。
&lt;a href=&quot;https://gcc.godbolt.org/&quot;&gt;https://gcc.godbolt.org/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;a&quot;&gt;a++&lt;/h2&gt;
&lt;p&gt;來考慮下面的程式碼：&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9527&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;丟到網站上就產生下面的 assembly code&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;test:
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], 9527
        mov     eax, DWORD PTR [rbp-4]
        lea     edx, [rax+1]
        mov     DWORD PTR [rbp-4], edx
        mov     DWORD PTR [rbp-8], eax
        nop
        pop     rbp
        ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我們只關注在 &lt;code class=&quot;highlighter-rouge&quot;&gt;int b=a++&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;        mov     eax, DWORD PTR [rbp-4]
        lea     edx, [rax+1]
        mov     DWORD PTR [rbp-4], edx
        mov     DWORD PTR [rbp-8], eax
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;第一行 &lt;code class=&quot;highlighter-rouge&quot;&gt;DWORD PTR [rbp-4]&lt;/code&gt; 代表變數 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 的位址，所以翻譯成中文就是把 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 的位址複製到暫存器 &lt;code class=&quot;highlighter-rouge&quot;&gt;eax&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在講解第二行之前必須先瞭解 eax 和 rax 的關係：
&lt;a href=&quot;https://stackoverflow.com/questions/25455447/x86-64-registers-rax-eax-ax-al-overwriting-full-register-contents&quot;&gt;rax, eax, ax, ah, al&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以及中括號(brackets)在 assembly language 的意義：
&lt;a href=&quot;https://stackoverflow.com/questions/48608423/what-do-square-brackets-mean-in-x86-assembly&quot;&gt;get the value of the address&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;因此第二行的翻譯就是將 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 加一後的值存入暫存器 &lt;code class=&quot;highlighter-rouge&quot;&gt;edx&lt;/code&gt;，注意這邊並不更改 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 在 memory 的值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;第三行的翻譯就是將儲存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;edx&lt;/code&gt; 的值(a+1)存入 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; memory 的所在位址。&lt;/li&gt;
  &lt;li&gt;第四行的翻譯就是將儲存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;eax&lt;/code&gt; 的值(a)存入 &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; memory 的所在位址。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此最後 &lt;code class=&quot;highlighter-rouge&quot;&gt;b=9527&lt;/code&gt; 然後 &lt;code class=&quot;highlighter-rouge&quot;&gt;a=9528&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;a-1&quot;&gt;++a&lt;/h2&gt;
&lt;p&gt;接下來考慮下面的程式碼：&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9527&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;丟到網站上就產生下面的 assembly code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;test:
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], 9527
        add     DWORD PTR [rbp-4], 1
        mov     eax, DWORD PTR [rbp-4]
        mov     DWORD PTR [rbp-8], eax
        nop
        pop     rbp
        ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我們只關注在 &lt;code class=&quot;highlighter-rouge&quot;&gt;int b=++a&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;        add     DWORD PTR [rbp-4], 1
        mov     eax, DWORD PTR [rbp-4]
        mov     DWORD PTR [rbp-8], eax
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;第一行直接使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt; 指令將 1 加到 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; memory 所在位址。&lt;/li&gt;
  &lt;li&gt;第二行將 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; memory 的值(a+1)存入 &lt;code class=&quot;highlighter-rouge&quot;&gt;eax&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;第三行將儲存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;eax&lt;/code&gt; 的值(a+1)存入 &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; memory 的所在位址。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有觀察到差異了嗎？&lt;/p&gt;

&lt;p&gt;C 對於 statement 的運算必須經由暫存器，因此關鍵在於暫存器所存的值是 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 還是 &lt;code class=&quot;highlighter-rouge&quot;&gt;a+1&lt;/code&gt;，不論是&lt;code class=&quot;highlighter-rouge&quot;&gt;a++&lt;/code&gt; 或是 &lt;code class=&quot;highlighter-rouge&quot;&gt;++a&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 在 memory 的值都會先加一。&lt;/p&gt;

&lt;h2 id=&quot;aa&quot;&gt;a=a++&lt;/h2&gt;
&lt;p&gt;考慮以下程式碼：&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9527&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;丟到網站上就產生下面的 assembly code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;test:
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], 9527
        mov     eax, DWORD PTR [rbp-4]
        lea     edx, [rax+1]
        mov     DWORD PTR [rbp-4], edx
        mov     DWORD PTR [rbp-4], eax
        nop
        pop     rbp
        ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我們只關注在 &lt;code class=&quot;highlighter-rouge&quot;&gt;a=a++&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;        mov     eax, DWORD PTR [rbp-4]
        lea     edx, [rax+1]
        mov     DWORD PTR [rbp-4], edx
        mov     DWORD PTR [rbp-4], eax
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根據上面的討論，這四行 assembly code 所代表的意義就是：將 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 的值複製到 &lt;code class=&quot;highlighter-rouge&quot;&gt;eax&lt;/code&gt;，然後利用暫存器 &lt;code class=&quot;highlighter-rouge&quot;&gt;edx&lt;/code&gt;將 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; memory 所在的位址的值加一，最後將&lt;code class=&quot;highlighter-rouge&quot;&gt;eax&lt;/code&gt;(a) 存回 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; memory 所在的位址，因此&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;並不會更改它的值。&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9527&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a=%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;會印出&lt;code class=&quot;highlighter-rouge&quot;&gt;a=9527&lt;/code&gt;。&lt;/p&gt;</content><author><name>srhuang</name></author><summary type="html">以下是科技公司面試常考的考題，主要是測驗你對於 a++ 和 ++a 的認知。 int a=9527; a=a++; printf(&quot;a=%d\n&quot;, a); 請問上面這段程式碼會印出什麼？</summary></entry><entry><title type="html">C++ Vector clear() and resize(0)</title><link href="http://localhost:4000/c++/2019/10/05/cplusplus-001.html" rel="alternate" type="text/html" title="C++ Vector clear() and resize(0)" /><published>2019-10-05T00:00:00+08:00</published><updated>2019-10-05T00:00:00+08:00</updated><id>http://localhost:4000/c++/2019/10/05/cplusplus-001</id><content type="html" xml:base="http://localhost:4000/c++/2019/10/05/cplusplus-001.html">&lt;p&gt;從 C++ STL source code 來了解 vector.clear() and vector.resize(0) 的差異。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;resource&quot;&gt;Resource&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/vector/vector/resize/&quot;&gt;resize&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/vector/vector/clear/&quot;&gt;clear&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/llvm/llvm-project/blob/master/libcxx/include/vector&quot;&gt;C++ Vector STL source code&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;stl-source-code-分析&quot;&gt;STL source code 分析&lt;/h2&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Tp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Allocator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size_type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__sz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;size_type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__cs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__cs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__sz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__sz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__cs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__cs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__sz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__destruct_at_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__begin_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__sz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;resize(0) 代表 &lt;code class=&quot;highlighter-rouge&quot;&gt;__sz=0&lt;/code&gt;，就會執行&lt;code class=&quot;highlighter-rouge&quot;&gt;__destruct_at_end(this-&amp;gt;__begin_)&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_NOEXCEPT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__destruct_at_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__begin_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;所以其實 &lt;code class=&quot;highlighter-rouge&quot;&gt;resize(0)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;clear&lt;/code&gt; 是一樣的。&lt;/p&gt;</content><author><name>srhuang</name></author><summary type="html">從 C++ STL source code 來了解 vector.clear() and vector.resize(0) 的差異。</summary></entry><entry><title type="html">快速了解 Formal Language (形式語言)</title><link href="http://localhost:4000/formal%20language/2019/09/15/formallanguage-001.html" rel="alternate" type="text/html" title="快速了解 Formal Language (形式語言)" /><published>2019-09-15T00:00:00+08:00</published><updated>2019-09-15T00:00:00+08:00</updated><id>http://localhost:4000/formal%20language/2019/09/15/formallanguage-001</id><content type="html" xml:base="http://localhost:4000/formal%20language/2019/09/15/formallanguage-001.html">&lt;p&gt;這篇文章只會簡單的介紹 formal language，目的是用最快的速度擁有最粗淺的了解，如果對於這個領域還有興趣，可以再分項一一往下研究。
Turing Machine 在 1936 年由 Alan Turing 提出後，便奠定了現今電腦的基礎，整個 Formal Language 大約是在 1930-1940 年代發展成熟，而人類第一台通用計算機 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E6%95%B8%E5%80%BC%E7%A9%8D%E5%88%86%E8%A8%88%E7%AE%97%E6%A9%9F&quot;&gt;ENIAC&lt;/a&gt; 則是 1946 的事情了。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#Definition&quot;&gt;Definition : Languages, Grammars, Automata&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#Regular&quot;&gt;Regular Languages and DFA&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#CFL&quot;&gt;Context-Free Languages and Pushdown Automata&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#REL&quot;&gt;Recursively enumerable Languages and Turing Machine&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#CSL&quot;&gt;Context-Sensitive Languages and Linear Bounded Automata&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#Chomsky&quot;&gt;The Chomsky Hierarchy&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#limits&quot;&gt;Limits of Algorithmic Computation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#complexity&quot;&gt;Computational Complexity&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;why-we-study-formal-language-theory&quot;&gt;Why we study formal language theory?&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;theory provides concepts and principles that help us understand the general nature of the discipline.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;學習理論讓我們知道計算機科學的最核心的概念和原則，進而了解電腦的極限，而不用透過無意義的 trial-and-error 以及猜測來理解電腦，以更高的角度來看待計算機科學。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;the ideas we will discuss have some immediate and important applications.e.g. digital design, programming languages, and compilers.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;就實作面來說，formal language 是 compiler 的理論基礎，因為 compiler 就是在處理語言和字串，本質上和 formal language 所探討的問題是一致的；programming languages 核心的概念也是把人類理解的語言，轉成機器可以執行的語言，不論高階語言還是低階語言，本質上都是處理語言和字串的轉換。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;the subject matter is intellectually stimulating and fun.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最後一個理由是，透過理解這些理論基礎和證明，會再次感受到前人研究的偉大，而我們也只是站在這些巨人的肩膀上，希望獲得新知識的過程能帶來無比的成就感以及樂趣。&lt;/p&gt;

&lt;p&gt;Using Formal Language :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;definition of programming languages.&lt;/li&gt;
  &lt;li&gt;interpreters.&lt;/li&gt;
  &lt;li&gt;compilers.&lt;/li&gt;
&lt;/ul&gt;

&lt;details&gt;
    &lt;summary&gt;關於 formal language 的翻譯
&lt;/summary&gt;
如果把 formal language 翻譯成「正規語言」，那 regular language 可能會不知道該如何翻譯，因此比較好的翻譯應該是「形式語言」，而「正規語言」是包含於「形式語言」。
&lt;/details&gt;

&lt;h2 id=&quot;definition--languages-grammars-automata&quot;&gt;&lt;a id=&quot;Definition&quot;&gt;&lt;/a&gt;Definition : Languages, Grammars, Automata&lt;/h2&gt;
&lt;p&gt;在開始討論 formal language 之前，我們必須對於要討論的對象做根本上的定義。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Languages&lt;/em&gt; 是一個數學上的字串集合；
這些字串集合的 derivation rules 就稱為 &lt;em&gt;Grammars&lt;/em&gt;；
而設計一個自動機來決定給定的字串是否屬於該集合則稱為 &lt;em&gt;Accepter&lt;/em&gt; (Automata 的一種)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Languages&lt;/strong&gt; 的例子：
&lt;script type=&quot;math/tex&quot;&gt;L_1=\{ a^nb^n : n \geq 0 \}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Automata&lt;/strong&gt; 基本上分為兩種：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Accepter : output response is limited to a simple “yes” or “no”.&lt;/li&gt;
  &lt;li&gt;Transducer : producing strings of symbols as output.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Grammars&lt;/strong&gt; 是用數學嚴謹的定義來描述 language：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;variables (V) : finite set.&lt;/li&gt;
  &lt;li&gt;terminal symbols (T) : finite set.&lt;/li&gt;
  &lt;li&gt;start variable (S) : special symbol.&lt;/li&gt;
  &lt;li&gt;productions (P) : which used to derives the strings.&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;G_1 = (\{A,S\},\{a,b\},S,P_1)\ with\ P_1\ consisting\ of\ the\ productions \\
S \to aAb|\lambda \\
A \to aAb|\lambda&lt;/script&gt;

&lt;p&gt;這個 Grammar 其實就是 Language $L_1$ 那個例子的 Grammar，所以 &lt;script type=&quot;math/tex&quot;&gt;L(G_1) = L_1&lt;/script&gt;。&lt;/p&gt;

&lt;h2 id=&quot;regular-languages-and-dfa&quot;&gt;&lt;a id=&quot;Regular&quot;&gt;&lt;/a&gt;Regular Languages and DFA&lt;/h2&gt;
&lt;p&gt;我們將會從最簡單的 automata 開始討論，由於接下來的 automata 都是 accepters，所以可以暫時理解 $automata=accepters$。&lt;/p&gt;

&lt;p&gt;Language 是一種字串的集合，關於這個集合我們會用各種角度和方式來描述它，讓它變得更加具體，其中一個就是設計一個 automata 讓所有該集合的字串都能通過該 automata(accepter)；Grammars 則是透過數學的方式來描述該 language。&lt;/p&gt;

&lt;h3 id=&quot;finite-automata-finite-state-machine-fsm&quot;&gt;Finite Automata (Finite State Machine, FSM)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Deterministic Finite Automata (DFA) is defined by internal states, input alphabet, transition function, initial state, final states.
    &lt;ul&gt;
      &lt;li&gt;each move consumes one input symbol.&lt;/li&gt;
      &lt;li&gt;the string is accepted if the automaton is in one of its final states.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Nondeterministic Finite Automata (NFA)
    &lt;ul&gt;
      &lt;li&gt;transition function range is a set of possible states.&lt;/li&gt;
      &lt;li&gt;can make a transition without consuming an input symbol.&lt;/li&gt;
      &lt;li&gt;there is no transition defined for the specific situation.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;The classes of DFA and NFA are equally powerfully.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;regular-language&quot;&gt;Regular Language&lt;/h3&gt;
&lt;p&gt;A language $L$ is called regular if and only if there exists some DFA $M$ such that, $L=L(M)$.&lt;/p&gt;

&lt;h3 id=&quot;regular-grammar&quot;&gt;Regular Grammar&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;A language $L$ is regular if and only if there exists a regular grammar $G$ such that $L=L(G)$.&lt;/li&gt;
  &lt;li&gt;A regular grammar is one that is either right-linear or left-linear, which there is exactly one variable occuring as the rightmost/leftmost symbol.&lt;br /&gt;
Right-Linear Grammars ：$A \to xB$&lt;br /&gt;
Left-Linear Grammars : $A \to Bx$&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;regular-expression&quot;&gt;Regular Expression&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;One way of describing regular language is via the notation of regular expression.&lt;/li&gt;
  &lt;li&gt;Two regular expressions are equivalent if they denote the same language.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;There are three ways to describe regular languages：DFA, regular expression, regular grammars.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;details&gt;
    &lt;summary&gt;想知道更多？
&lt;/summary&gt;
&lt;ul&gt;
  &lt;li&gt;Closure Properties of Regular Languages&lt;/li&gt;
  &lt;li&gt;membership algorithm&lt;/li&gt;
  &lt;li&gt;Identifying Nonregular Languages
    &lt;ul&gt;
        &lt;li&gt;Pigeonhole Principle (鴿籠原理)&lt;/li&gt;
        &lt;li&gt;Pumping Lemma&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;

&lt;h2 id=&quot;context-free-languages-and-pushdown-automata&quot;&gt;&lt;a id=&quot;CFL&quot;&gt;&lt;/a&gt;Context-Free Languages and Pushdown Automata&lt;/h2&gt;
&lt;p&gt;雖然 regular language 廣泛應用在 computer science 領域中，但是還是有很多是 regular language 無法處理的，例如我們舉的第一個例子：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;L_1=\{ a^nb^n : n \geq 0 \}&lt;/script&gt;

&lt;p&gt;假如 $a=“(”, b=”)”$，那麼這個 language 所產生的 automata 將會是判斷 programming language 的括號是否合法的方法之一。可以想像的是，利用 finite state 將無法紀錄已經 parsing 幾個 a 了，因此我們需要更強大的 language 來處理 regular language 無法處理的 language。
最核心的概念就是在 finite state 以外新增 storage (stack)。你將會發現「新增/修改 storage」是區別每個 language 所對應的 automata 重要的 property 之一。&lt;/p&gt;

&lt;h3 id=&quot;context-free-grammars&quot;&gt;Context-Free Grammars&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;all productions in P have the form $A \to x$.&lt;/li&gt;
  &lt;li&gt;retaining the restriction on the left side, but permitting anything on the right.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;context-free-languages&quot;&gt;Context-Free Languages&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;A language $L$ is said to be context-free if and only if there is a context-free grammar $G$ such that $L=L(G)$.&lt;/li&gt;
&lt;/ul&gt;

&lt;details&gt;
    &lt;summary&gt;想知道更多？
&lt;/summary&gt;
&lt;ul&gt;
  &lt;li&gt;Derivation Tree (Parse tree)&lt;/li&gt;
  &lt;li&gt;Sentential form of the derivation&lt;/li&gt;
  &lt;li&gt;Parsing and Ambiguity
    &lt;ul&gt;
        &lt;li&gt;exhaustive search parsing (brute force parsing)&lt;/li&gt;
        &lt;li&gt;Simple Grammar (s-grammar)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Simplification of Context-Free Grammars and Normal Forms
    &lt;ul&gt;
        &lt;li&gt;Chomsky Normal Form : A-&amp;gt;BC or A-&amp;gt;a&lt;/li&gt;
        &lt;li&gt;Greibach Normal Form : A-&amp;gt;ax&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;

&lt;h3 id=&quot;pushdown-automata&quot;&gt;Pushdown Automata&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Nondeterministic Pushdown Automata (NPDA)
    &lt;ul&gt;
      &lt;li&gt;For any context-free language $L$, there exists an NPDA $M$ such that $L=L(M)$.&lt;/li&gt;
      &lt;li&gt;If $L=L(M)$ for some NPDA $M$, then $L$ is a context-free language.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Deterministic Pushdown Automata (DPDA)
    &lt;ul&gt;
      &lt;li&gt;A language $L$ is said to be a deterministic context-free language if and only if there exists a DPDA $M$ such that $L=L(M)$.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;deterministic and nondeterministic pushdown automata are not equivalent.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;details&gt;
    &lt;summary&gt;想知道更多？
&lt;/summary&gt;
&lt;ul&gt;
  &lt;li&gt;Properties of Context-Free Languages
    &lt;ul&gt;
        &lt;li&gt;A pumping lemma for context-free languages&lt;/li&gt;
        &lt;li&gt;Closure Properties for Context-Free Languages&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;

&lt;h2 id=&quot;recursively-enumerable-languages-and-turing-machine&quot;&gt;&lt;a id=&quot;REL&quot;&gt;&lt;/a&gt;Recursively enumerable Languages and Turing Machine&lt;/h2&gt;
&lt;p&gt;我們發現還是有 Language 不屬於 regular and context-free language&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;L_1=\{ a^nb^nc^n : n \geq 0 \}&lt;/script&gt;

&lt;p&gt;因此透過修改 storage 可以得到更 powerful 的 language : Turing Machine (Using Tapes).&lt;/p&gt;

&lt;h3 id=&quot;turing-machine&quot;&gt;Turing Machine&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Definition : associated with the tape is a read-write head that can travel right or left.&lt;/li&gt;
  &lt;li&gt;The Turing machine enters a final state and halts, then the string is considered to be accepted.&lt;/li&gt;
  &lt;li&gt;main features :
    &lt;ul&gt;
      &lt;li&gt;tape is unbounded in both directions.&lt;/li&gt;
      &lt;li&gt;deterministic.&lt;/li&gt;
      &lt;li&gt;no special input file / output device.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Church Turing Thesis : 任何在算法上可計算的問題同樣可由圖靈機計算。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;recursively-enumerable-languages&quot;&gt;Recursively enumerable Languages&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;A language $L$ is said to be recursively enumerable if there exists a Turing machine that accepts it.&lt;/li&gt;
  &lt;li&gt;There is an &lt;em&gt;enumeration procedure&lt;/em&gt; for every recursively enumerable language.&lt;/li&gt;
  &lt;li&gt;enumeration procedure : 存在一個 algorithm 可以列出所有 strings in the language.&lt;/li&gt;
  &lt;li&gt;Recursively enumerable Languages is countable.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;recursive-languages&quot;&gt;Recursive Languages&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;A language is recursive in and only if there exists a &lt;em&gt;membership algorithm&lt;/em&gt; for it.&lt;/li&gt;
  &lt;li&gt;membership algorithm : 存在一個 algorithm 可以決定該 string 是否屬於 language。&lt;/li&gt;
  &lt;li&gt;If a language is recursive, then there exists an enumeration procedure.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;the family of recursive language is a proper subset of the family of recursively enumerable languages.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;details&gt;
    &lt;summary&gt;想知道更多？
&lt;/summary&gt;
&lt;ul&gt;
  &lt;li&gt;這邊常用的證明方法 : diagonalization&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;

&lt;h3 id=&quot;unrestricted-grammars&quot;&gt;Unrestricted Grammars&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;A grammar is called unrestricted if all the productions are of the form $u \to v$.&lt;/li&gt;
  &lt;li&gt;Any number of variables and terminals can be on the left or righting any order.&lt;/li&gt;
  &lt;li&gt;Any language generated by an unrestricted grammar is &lt;em&gt;recursively enumerable&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;For every recursively enumeration language $L$, there exists an unrestricted grammar $G$, such that $L=L(G)$.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;context-sensitive-languages-and-linear-bounded-automata&quot;&gt;&lt;a id=&quot;CSL&quot;&gt;&lt;/a&gt;Context-Sensitive Languages and Linear Bounded Automata&lt;/h2&gt;
&lt;p&gt;Context-free languages，顧名思義就在 derivation 的時候並不考慮上下文，因此根據 definition，there is no terminal on the left of any production.接下來將會介紹根據上下文的 Context-Sensitive Languages。&lt;/p&gt;

&lt;h3 id=&quot;context-sensitive-grammars&quot;&gt;Context-Sensitive Grammars&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;A grammar is called Context-Sensitive if all the productions are of the form $x \to y$, where &lt;script type=&quot;math/tex&quot;&gt;\|x\| \leq \|y\|&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;the length of successive sentential forms can never decrease.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;linear-bounded-automata&quot;&gt;Linear Bounded Automata&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Turing machine with limiting the tape.&lt;/li&gt;
  &lt;li&gt;For every context-sensitive language $L$ (not including empty string), there exists some linear bounded automata $M$ such that $L=L(M)$.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;context-sensitive-languages&quot;&gt;Context-Sensitive Languages&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;A language $L$ is said to be context-sensitive if and only if there is a context-sensitive grammar $G$ such that $L=L(G)$.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;the-chomsky-hierarchy&quot;&gt;&lt;a id=&quot;Chomsky&quot;&gt;&lt;/a&gt;The Chomsky Hierarchy&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Type 0 : recursively enumerable languages (unrestricted grammars).&lt;/li&gt;
  &lt;li&gt;Type 1 : context-sensitive language.&lt;/li&gt;
  &lt;li&gt;Type 2 : context-free language.&lt;/li&gt;
  &lt;li&gt;Type 3 : regular language.&lt;/li&gt;
&lt;/ul&gt;

&lt;details&gt;
    &lt;summary&gt;想知道更多？
&lt;/summary&gt;
&lt;ul&gt;
  &lt;li&gt;Recursive Languages&lt;/li&gt;
  &lt;li&gt;Linear Languages&lt;/li&gt;
  &lt;li&gt;Determinitstic Context-Free Languages&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;

&lt;h2 id=&quot;limits-of-algorithmic-computation&quot;&gt;&lt;a id=&quot;limits&quot;&gt;&lt;/a&gt;Limits of Algorithmic Computation&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;Computable Functions : It states that a function on the natural numbers can be calculated by an effective method, if and only if it is computable by a Turing machine.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;接下來，我們將會討論那些 Turing machine 無法處理的問題，在討論之前，先介紹幾個概念。&lt;/p&gt;

&lt;h3 id=&quot;computability&quot;&gt;Computability&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;A function $f$ is said to be computable if there exists a Turing Machine that computes the value of $f$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;decidability&quot;&gt;Decidability&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;The result of a computation is simple “yes” or “no”, in this case, a problem being decidable or undecidable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;the-turing-machine-halting-problem&quot;&gt;The Turing Machine Halting Problem&lt;/h4&gt;
&lt;p&gt;「給定一個 input string 和 Turing Machine，把 string 丟進去 Turing Machine 執行後是否會停在某個 state，抑或是執行後永不停止。」&lt;/p&gt;

&lt;p&gt;這個問題是 undecidable，證明方法主要是利用反證法：If halting problem were decidable, then every recursively enumerable language would be recursive. 因為如果知道會不會停止，就可以建構出 membership algorithm，而凡是可以建構出 membership algorithm 的 language 就是 recursive language。&lt;/p&gt;

&lt;p&gt;可以 reduced to Halting Problem 的問題：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The state-entry Problem : the state is ever entered when applied to input string.&lt;/li&gt;
  &lt;li&gt;The blank-tape halting Problem : Turing machine halts if started with a blank tape.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;證明的方法就是利用該 Problem 建構出 Halting Problem，但已知 Halting Problem is undecidable，因此該 Problem 也是 undecidable (反證法)。&lt;/p&gt;

&lt;details&gt;
    &lt;summary&gt;想知道更多？
&lt;/summary&gt;
&lt;ul&gt;
  &lt;li&gt;Undecidable Problems for Recursively Enumerable Languages&lt;/li&gt;
  &lt;li&gt;The Post Correspondence Problem&lt;/li&gt;
  &lt;li&gt;Undecidable Problems for Context-Free Languages&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;

&lt;h2 id=&quot;computational-complexity&quot;&gt;&lt;a id=&quot;complexity&quot;&gt;&lt;/a&gt;Computational Complexity&lt;/h2&gt;
&lt;p&gt;我們只介紹 P Problem, NP Problem。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;P Problem : Includes all languages that are accepted by some &lt;em&gt;deterministic&lt;/em&gt; Turing machine in polynomial time. 指的是有明確 polynomial time 的解法 (通常指的是暴力解)。&lt;/li&gt;
  &lt;li&gt;NP Problem : Includes all languages that are accepted by some &lt;em&gt;nondeterministic&lt;/em&gt; Turing machine in polynomial time. 提供一個解法，可以在 polynomial time 被驗證 (通常暴力解會是 exponential time)。&lt;/li&gt;
&lt;/ul&gt;

&lt;details&gt;
    &lt;summary&gt;想知道更多？
&lt;/summary&gt;
&lt;ul&gt;
  &lt;li&gt;The SAT problem (NP)&lt;/li&gt;
  &lt;li&gt;The Hamiltonian Path Problem (NP)&lt;/li&gt;
  &lt;li&gt;The Clique Problem (NP)&lt;/li&gt;
  &lt;li&gt;NP-compete Problem&lt;/li&gt;
  &lt;li&gt;NP-hard Problem&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;

&lt;h2 id=&quot;resource&quot;&gt;Resource&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;An Introduction to Formal Language and Automata (Peter Linz)&lt;/li&gt;
  &lt;li&gt;Introduction to Automata Theory, Languages, and Computation (Hopcroft, Motwani, Ullman)&lt;/li&gt;
  &lt;li&gt;Introduction to the Theory of Computation (Michael Sipser)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mropengate.blogspot.com/2015/06/formal-language.html&quot;&gt;正規語言Formal Language | Mr. Opengate
&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PLBlnK6fEyqRgp46KUv4ZY69yXmpwKOIev&quot;&gt;Theory of Computation &amp;amp; Automata Theory&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>srhuang</name></author><category term="theory" /><category term="mathematics" /><summary type="html">這篇文章只會簡單的介紹 formal language，目的是用最快的速度擁有最粗淺的了解，如果對於這個領域還有興趣，可以再分項一一往下研究。 Turing Machine 在 1936 年由 Alan Turing 提出後，便奠定了現今電腦的基礎，整個 Formal Language 大約是在 1930-1940 年代發展成熟，而人類第一台通用計算機 ENIAC 則是 1946 的事情了。</summary></entry></feed>